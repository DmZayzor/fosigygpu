# -*- coding: utf-8 -*-
"""pixel_cut.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L3MUd2L_oiRbjH2iZ1d3N3F67KNMgjQr
"""

import skimage.io
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from osgeo import gdal,osr
from PIL import Image

def crear_color(banda):
    banda_color = (banda/2135)*255
    return banda_color

def crear_multi(im_multi):
    lista_union = []
    n_bandas = int(im_multi.shape[2])
    i=0

    while i < n_bandas:
        banda = im_multi[:,:,i]
        banda_float = banda.astype(np.float32)
        banda_color = crear_color(banda_float)
        banda_imagen = banda_color.astype(np.uint8)
        lista_union.append(banda_imagen)
        i=i+1
    
    fusioned_image = np.stack((lista_union),axis = 2)
    return fusioned_image

def fusionar_con_info(rgb,data,bandas,name):

    info = gdal.Info(data)
    cols = data.RasterXSize
    rows = data.RasterYSize
    origen = data.GetGeoTransform()
    origenX = origen[0]
    origenY = origen[3]
    pixelWidth=origen[1]
    pixelHeight=origen[5]
    driver = gdal.GetDriverByName("GTiff")
    proy = data.GetProjection()
    outRaster = driver.Create(name, cols, rows, bandas, gdal.GDT_Byte)
    outRaster.SetGeoTransform((origenX, pixelWidth, origen[2], origenY,origen[4], pixelHeight))
    if bandas ==1:
        outRaster.GetRasterBand(1).WriteArray(rgb)
        outRaster.GetRasterBand(1).SetNoDataValue(np.nan)
    else:
        for i in range(bandas):
            band = i+1
            banda = rgb[:,:,i]
            outRaster.GetRasterBand(band).WriteArray(banda)
            outRaster.GetRasterBand(band).SetNoDataValue(np.nan)
            i = i+1
    
    s_ref = osr.SpatialReference()
    s_ref.ImportFromWkt(proy)
    outRaster.SetProjection(s_ref.ExportToWkt())
    outRaster.FlushCache()
    return outRaster

def crear_pancro(im_pan):
    banda_float = im_pan.astype(np.float32)
    maxElement = np.amax(banda_float)
    banda_gray = (banda_float/maxElement)*255
    banda_imagen = banda_gray.astype(np.uint8)
    fusioned_image = banda_imagen
    return fusioned_image

def multiplicar_pixel(rgb):

    source = "rgb8.tif"
    driverTiff = gdal.GetDriverByName("GTiff")
    new_multi = gdal.Open(source)
    info_multi = gdal.Info(new_multi)

    old_pixel = int(input('pixeles actuales: '))
    new_pixel = int(input('pixeles deseados: '))

    filas = new_multi.RasterYSize
    colum = new_multi.RasterXSize
    bands = new_multi.RasterCount
    
    b = 0
    extend_band = np.zeros((filas*new_pixel,colum*new_pixel))
    band_list =[]
    while b < bands:
        for old_fil in range(filas):
            for old_col in range(colum):
                for new_fil in range(new_pixel):
                    k_1=(old_fil*new_pixel)+new_fil
                    for new_col in range(new_pixel):
                        w_1=(old_col*new_pixel)+new_col
                        extend_band[k_1][w_1] = rgb[old_fil,old_col,b]
        b=b+1
        band_uint = extend_band.astype(np.uint8)
        band_list.append(band_uint)
        
    fusioned_image = np.stack((band_list),axis = 2)
    nombre = "multi.tif"
    expansion_multi, origen = fusionar_expansion_con_info(fusioned_image,nombre,new_multi,old_pixel)

    return fusioned_image, origen, new_pixel

def fusionar_expansion_con_info(rgb,name,data,pixel):

    bandas = rgb.shape[2]
    cols = rgb.shape[0]
    rows = rgb.shape[1]
    origen = data.GetGeoTransform()
    origenX = origen[0]
    origenY = origen[3]
    x_cor = origenX+(data.RasterXSize*pixel)
    y_cor = origenY-(data.RasterYSize*pixel)
    pixelWidth=origen[1]
    pixelHeight=origen[5]
    driver = gdal.GetDriverByName("GTiff")
    proy = data.GetProjection()
    
    outRaster = driver.Create(name, rows, cols, bandas, gdal.GDT_Byte)
    outRaster.SetGeoTransform((origenX, pixelWidth, x_cor, y_cor,origenY, pixelHeight))
    
    for i in range(bandas):
        band = i+1
        banda = rgb[:,:,i]
        outRaster.GetRasterBand(band).WriteArray(banda)
        outRaster.GetRasterBand(band).SetNoDataValue(np.nan)
        i = i+1
    
    s_ref = osr.SpatialReference()
    s_ref.ImportFromWkt(proy)
    outRaster.SetProjection(s_ref.ExportToWkt())
    outRaster.FlushCache()
    return outRaster,origen

def igualar_rgb(multi,p,data):

    n_bandas = multi.shape[2]
    izquierda = 310*4
    arriba = 320*4
    derecha = 3800
    abajo = 4310

    lista_union = []
    i=0
    while i < n_bandas:
        banda = multi[:,:,i]
        banda_img = Image.fromarray(np.uint8(banda))
        banda_rec = banda_img.crop((izquierda, arriba, derecha, abajo))
        banda_array = np.array(banda_rec)
        banda_int = banda_array.astype(np.uint8)
        lista_union.append(banda_int)
        i=i+1
    nombre = "multi_con_info.tif"
    fusioned_image = np.stack((lista_union),axis = 2)
    fusioned_con_info , origen= fusionar_expansion_con_info(fusioned_image,nombre,data,p)
    return fusioned_image

def dibujar_recuadro(im):
    
    coor_x = int(input('x coordinate '))*1.5
    coor_y = int(input('y coordinate  '))*1.45
    ancho = int(input('trim width  '))*4
    alto = int(input('trim height  '))*4
    
    ax = plt.gca()
    rect = patches.Rectangle((coor_x,coor_y),
                 ancho,                
                 alto,
                 linewidth=2,
                 edgecolor='cyan',
                 fill = False)

    ax.add_patch(rect)
    xIntrinsic=[coor_x , (coor_x + ancho)]
    yIntrinsic=[(coor_y + alto) , coor_y]

    return xIntrinsic, yIntrinsic,alto,ancho

def recortar_rgb(x,y,origen,dimen,h,w,p,rgb):

    xworld=[origen[0],origen[0]+dimen.shape[1]]
    yworld=[origen[3]-dimen.shape[0],origen[3]]

    new_xworld =[xworld[0] + x[0]*p, xworld[0] + x[1]*p]
    new_yworld =[yworld[1] - y[0]*p, yworld[1] - y[1]*p]

    izquierda = x[0]+8
    arriba = y[1]
    derecha = izquierda + w
    abajo = arriba + h
    rgb_rec = rgb.crop((izquierda, arriba, derecha, abajo))
    recorte_float = np.array(rgb_rec)
    recorte_int = recorte_float.astype(np.uint8)
    recorte_rgb = np.stack((recorte_int),axis = 2)
    recorte_rgb_invertido = recorte_rgb.transpose((-1, -3, -2))
    nombre="multirec.tif"
    data=gdal.Open("multi_con_info.tif")
    bandas=recorte_rgb_invertido.shape[2]
    fusionar=fusionar_recorte_con_info(recorte_rgb_invertido,nombre,data,new_xworld,new_yworld,bandas)
    return recorte_rgb_invertido

def recortar_pan(x,y,origen,dimen,h,w,p,pan):
    xworld=[origen[0],origen[0]+dimen.shape[1]]
    yworld=[origen[3]-dimen.shape[0],origen[3]]

    new_xworld =[xworld[0] + x[0]*4, xworld[0] + x[1]*4]
    new_yworld =[yworld[1] - y[0]*4, yworld[1] - y[1]*4]

    izquierda = (x[0])-20
    arriba = (y[1])-50
    derecha = izquierda + w
    abajo = arriba + h

    pan_rec = pan.crop((izquierda, arriba, derecha,abajo))
    recorte_float = np.array(pan_rec)
    recorte_int = recorte_float.astype(np.uint8)
    
    nombre="panrec.tif"
    data=gdal.Open("multi_con_info.tif")
    bandas=1
    fusionar=fusionar_recorte_con_info(recorte_int,nombre,data,new_xworld,new_yworld,bandas)
    return recorte_int

def fusionar_recorte_con_info(rgb,name,data,x,y,b):
  
    cols = data.RasterXSize
    rows = data.RasterYSize
    origen = data.GetGeoTransform()
    print(origen)
    origenX = origen[0]
    origenY = origen[3]
    pixelWidth=origen[1]
    pixelHeight=origen[5]
    driver = gdal.GetDriverByName("GTiff")
    proy = data.GetProjection()

    outRaster = driver.Create(name, cols, rows, b, gdal.GDT_Byte)
    outRaster.SetGeoTransform((origenX, pixelWidth, x[1], origenY,y[0], pixelHeight))
    if b == 1:
        outRaster.GetRasterBand(1).WriteArray(rgb)
        outRaster.GetRasterBand(1).SetNoDataValue(np.nan)
    else:
        for i in range(b):
            band = i+1
            banda = rgb[:,:,i]
            outRaster.GetRasterBand(band).WriteArray(banda)
            outRaster.GetRasterBand(band).SetNoDataValue(np.nan)
            i = i+1
    
    s_ref = osr.SpatialReference()
    s_ref.ImportFromWkt(proy)
    outRaster.SetProjection(s_ref.ExportToWkt())
    outRaster.FlushCache()
    return outRaster

def expandir_recorte_rgb(rgb,pixel): 
    filas = rgb.shape[0]
    colum = rgb.shape[1]
    bands = rgb.shape[2]

    print("filas",filas, "colum", colum,"bands",bands)
    b = 0
    extend_band = np.zeros((filas*pixel,colum*pixel))
    band_list =[]
    while b < bands:
        for old_fil in range(filas):
            for old_col in range(colum):
                for new_fil in range(pixel):
                    k_1=(old_fil*pixel)+new_fil
                    for new_col in range(pixel):
                        w_1=(old_col*pixel)+new_col
                        extend_band[k_1][w_1] = rgb[old_fil,old_col,b]
        b=b+1
        band_uint = extend_band.astype(np.uint8)
        band_list.append(extend_band)
    fusioned_image = np.stack((band_list),axis = 2)
 
    return fusioned_image

def crear_imagenes(rgb,data_rgb,pan,data_pan):

    new_rgb = crear_multi(rgb)
    bandas_rgb=new_rgb.shape[2]
    name_rgb="rgb8.tif"
    multi_con_info = fusionar_con_info(new_rgb,data_rgb,bandas_rgb,name_rgb)
    new_pan = crear_pancro(pan)
    
    bandas_pan=1
    name_pan="pan8.tif"
    pan_con_info = fusionar_con_info(new_pan,data_pan,bandas_pan,name_pan)
    pixel_multiplicado, origen, pixel = multiplicar_pixel(new_rgb)
    return pixel_multiplicado,origen,pixel

inicial_rgb = skimage.io.imread('rgbikonos.tif', plugin='tifffile')
data_rgb = gdal.Open("rgbikonos.tif")
inicial_pan = skimage.io.imread('ikonospanrecorte.tif', plugin='tifffile')
data_pan = gdal.Open("ikonospanrecorte.tif")
pixel_multiplicado,origen,pixel=crear_imagenes(inicial_rgb,data_rgb,inicial_pan,data_pan)

multi = skimage.io.imread('multi.tif', plugin='tifffile')
data_multi = gdal.Open("multi.tif")
rgb_igualada = igualar_rgb(multi,pixel,data_multi)


rgb=Image.open("multi_con_info.tif")
xIntrinsic, yIntrinsic, H, W = dibujar_recuadro(rgb)
rgb_rec = recortar_rgb(xIntrinsic,yIntrinsic,origen,pixel_multiplicado,H,W,pixel,rgb)
dibujar_rgb_rec = skimage.io.imsave('multirec.tif',rgb_rec, plugin ='tifffile')

pan=Image.open("pan8.tif")
pan_rec = recortar_pan(xIntrinsic,yIntrinsic,origen,pixel_multiplicado,H,W,pixel,pan)
dibujar_rgb_rec = skimage.io.imsave('panrec.tif',pan_rec, plugin ='tifffile')

recorte_rgb = skimage.io.imread('multirec1.tif', plugin='tifffile')
rgb_rec_final = expandir_recorte_rgb(recorte_rgb,pixel)
dibujar_rec_final_rgb = skimage.io.imsave('rgbdef.tif',rgb_rec_final, plugin ='tifffile')