# -*- coding: utf-8 -*-
"""Fusion_paso_alto_gpu.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W4SyedDOSRQ4LyS6GRWv1m8VIE2NqCFF
"""


import pycuda.autoinit
import numpy as np
import skimage.io
from scipy import ndimage
import pycuda.driver as drv
import pycuda.gpuarray as gpuarray
import skcuda.linalg as linalg
import skcuda.misc as misc
import skimage
from pycuda.elementwise import ElementwiseKernel

linalg.init()
def fusionar_gpu(banda, filtro1, filtro2):

    print("entro a fusionar gpu")
    filtro1_gpu = gpuarray.to_gpu(filtro1)
    filtro2_gpu = gpuarray.to_gpu(filtro2)
    banda_gpu = gpuarray.to_gpu(banda)
    division = misc.divide(banda_gpu, filtro2_gpu)
    multiplicacion = linalg.multiply(division, filtro1_gpu)
    fusion_gpu = banda_gpu + multiplicacion
    
    return fusion_gpu.get()

def ajustar_valores_negativos(matrix):
  
    print("entr√≥ a ajustar valores")
    matrix_gpu = gpuarray.to_gpu(matrix)
    matrix_gpu_new = gpuarray.empty_like(matrix_gpu)

    adjustment_values = ElementwiseKernel(
        "float *x, float *z",
        "if(x[i] < 0){z[i] = 0.0;}else{z[i] = x[i];}",
        "adjust_value")
    adjustment_values(matrix_gpu,matrix_gpu_new)
   
    return matrix_gpu_new.get()

def ajustar_valores_mayores(matrix):

    matrix_gpu = gpuarray.to_gpu(matrix)
    matrix_gpu_new = gpuarray.empty_like(matrix_gpu)
    adjustment_values = ElementwiseKernel(
        "float *x, float *z",
        "if(x[i] > 255){z[i] = 255.0;}else{z[i] = x[i];}",
        "adjust_value")
    adjustment_values(matrix_gpu,matrix_gpu_new)
   
    return matrix_gpu_new.get()

filtro1 = np.array([[-1, -1, -1],[-1, 9, -1],[-1, -1, -1]]) * (1/9)
filtro2 = np.array([[1, 1, 1],[1, 1, 1],[1, 1, 1]]) * (1/9)

def fusion_paso_alto_gpu(multi, pan):

    listaunion = []
    n_bandas = int(multi.shape[2])
    double_pan = pan.astype(np.float32)

    imagen1 = ndimage.correlate(double_pan, filtro1, mode='constant')
    imagen2 = ndimage.correlate(double_pan, filtro2, mode='constant')

    imagen1=ajustar_valores_negativos(imagen1)
    imagen2=ajustar_valores_negativos(imagen2)

    double_imagen1 = imagen1.astype(np.float32)
    double_imagen2 = imagen2.astype(np.float32)

    i = 0
    while i < n_bandas:
        banda = multi[:,:,i]
        banda_float = banda.astype(np.float32)
        fusionbandas = fusionar_gpu(banda_float, double_imagen1, double_imagen2)
        fusionbandas = ajustar_valores_mayores(fusionbandas)
        to_image = fusionbandas.astype(np.uint8)
        listaunion.append(to_image)
        i = i + 1
    fusioned_image = np.stack((listaunion),axis = 2)

    return fusioned_image